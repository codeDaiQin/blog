---
title: ä¸ä¸€æ ·çš„å·¥å…·ç±»
date: '2022-07-06'
tags: ['TypeScript']
draft: false
summary: TypeScript å…¨é¢è¿›é˜¶æŒ‡å—
---

# TypeScript ç±»å‹å·¥å…· ğŸ”§

> `ç±»å‹åˆ«å type + æ³›å‹ <T> => å·¥å…·ç±»`

## å·¥å…·ç±»

### å¸¸è§å·¥å…·ç±»

```ts
// keyof any => string | number | symbol
// å› ä¸ºkeyåªèƒ½ä¸ºä»¥ä¸Šç±»å‹
type Record<K extends keyof any, T> = { [P in K]: T }

// ä»Tç±»å‹ä¸­æ’é™¤U è¿”å› å‰©ä½™çš„Key
type Exclude<T, U> = T extends U ? never : T

// ä»Tç±»å‹ä¸­ é€‰å– K
type Pick<T, K extends keyof T> = { [P in K]: T[P] }

// ä»Tç±»å‹ä¸­ æ’é™¤ K å­—æ®µ
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>
```

## æ“ä½œç¬¦

### keyof

```ts
type Cat = {
  name: string
  age: number
}

// => 'name' | 'age' è”åˆç±»å‹
type Keys = keyof Cat
```

### typeof

```ts
const foo = {
  name: 'mmc',
  age: 17,
}
// => { name: string, age: number }
type Bar = typeof foo
```

### in å…³é”®å­—

```ts
// ä¼šéå†è¿™ä¸ª keyof Tè¿”å›çš„è”åˆç±»å‹
type Readonly<T> = {
  readonly [P in keyof T]: T[P]
}

interface Foo {
  prop1: string
  prop2: number
  prop3: boolean
  prop4: () => void
}

type TestReadonly1 = Readonly<Foo>

// ç­‰ä»·äº
interface TestReadonly2 {
  readonly prop1: string
  readonly prop2: number
  readonly prop3: boolean
  readonly prop4: () => void
}

// ç”¨ä¼ªä»£ç è¡¨ç¤º
const Foo = {}
for (const K of Object.keys(T)) {
  Foo[K] = readonly T[K]
}
```

### is å…³é”®å­—

> is å…³é”®å­— + é¢„æœŸç±»å‹

ä»€ä¹ˆæ—¶å€™ä¼šç”¨åˆ° is

å…ˆçœ‹è¿™ä¸ªä¾‹å­

```ts
function isString(value: unknown): boolean {
  return typeof value === 'string'
}

function foo(value: string | number) {
  if (isString(value)) {
    // ç±»å‹â€œstring | numberâ€ä¸Šä¸å­˜åœ¨å±æ€§â€œreplaceâ€ã€‚
    value.replace('mmc', 'huige666')
    // å› ä¸º isStringå‡½æ•°ä¸åœ¨fooä¸­ï¼Œç±»å‹åˆ†æåšä¸åˆ°è·¨å‡½æ•°ä¸Šä¸‹ä¿¡æ¯æ”¶é›†
  }
  if (typeof value === 'number') {
    // ...
  }
}
```

ä¸ºäº†è§£å†³è¿™ä¸€ç±»å‹æ§åˆ¶æµåˆ†æçš„èƒ½åŠ›ä¸è¶³, TypeScript å¼•å…¥äº† is å…³é”®å­—æ¥æ˜¾å¼åœ°æä¾›ç±»å‹ä¿¡æ¯

```ts
const isNumber = (value: unkown): value is number => {
  // å¦‚æœ return true å³ä¸º é¢„æœŸç±»å‹
  return typeof value === 'number'
}
```

### infer å…³é”®å­—

```ts
type Func = (...args: any[]) => any

// åˆ¤æ–­Tçš„ è¿”å›ç±»å‹æ˜¯å¦ä¸º string
type FunctionConditionType<T extends Func> = T extends (...args: any[]) => string
  ? 'A string return func!'
  : 'A non-string return func!'

//  "A string return func!"
type StringResult = FunctionConditionType<() => string>
// 'A non-string return func!';
type NonStringResult1 = FunctionConditionType<() => boolean>
// 'A non-string return func!';
type NonStringResult2 = FunctionConditionType<() => number>
```

æ¡ä»¶ç±»å‹ç”¨äºåˆ¤æ–­ä¸¤ä¸ªå‡½æ•°ç±»å‹æ˜¯å¦å…·æœ‰å…¼å®¹æ€§ï¼Œè€Œæ¡ä»¶ä¸­å¹¶ä¸é™åˆ¶å‚æ•°ç±»å‹ï¼Œä»…æ¯”è¾ƒäºŒè€…çš„è¿”å›å€¼ç±»å‹ã€‚

infer å…³é”®å­—æ¥åœ¨æ¡ä»¶ç±»å‹ä¸­æå–ç±»å‹çš„æŸä¸€éƒ¨åˆ†ä¿¡æ¯ï¼Œæ¯”å¦‚ä¸Šé¢æˆ‘ä»¬è¦æå–å‡½æ•°è¿”å›å€¼ç±»å‹çš„è¯ï¼Œå¯ä»¥è¿™ä¹ˆæ”¾ï¼š

```ts
type FunctionReturnType<T extends Func> = T extends (...args: any[]) => infer R ? R : never
```

å½“ä¼ å…¥çš„ç±»å‹å‚æ•°æ»¡è¶³ `T extends (...args: any[] ) => infer R` è¿™æ ·ä¸€ä¸ªç»“æ„ï¼ˆä¸ç”¨ç®¡ `infer R`ï¼Œå½“å®ƒæ˜¯ any å°±è¡Œï¼‰ï¼Œè¿”å› `infer R` ä½ç½®çš„å€¼ï¼Œå³ `R`ã€‚å¦åˆ™ï¼Œè¿”å› `never`.

> å®é™…åº”ç”¨

```ts
type Swap<T extends any[]> = T extends [infer A, infer B] ? [B, A] : T

// ç¬¦åˆç»“æ„ => [2, 1]
type SwapTest1 = Swap<[1, 2]>

// ä¸ç¬¦åˆç»“æ„ è¿”å›åŸç±»å‹ => [1, 2, 3]
type SwapTest2 = Swap<[1, 2, 3]>
```

ç”±äºå£°æ˜çš„ç»“æ„æ˜¯é•¿åº¦ 2 çš„å…ƒç»„ï¼Œå¾ˆéš¾åœ¨å®é™…å¼€ä¸­åº”ç”¨ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ rest æ“ä½œç¬¦æ¥å¤„ç†ä»»æ„é•¿åº¦

```ts
type Swap<T extends any[]> = T extends [infer Start, ...infer Ather, infer End]
  ? [End, ...Ather, Start]
  : T
```

## ç´¢å¼•ç±»å‹è®¿é—®

```ts
interface StringMap {
  name: string
}
type String = StringMap['name'] // => string
```

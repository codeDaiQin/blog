---
title: 不一样的工具类
date: '2022-07-06'
tags: ['TypeScript']
draft: false
summary: TypeScript 全面进阶指南
---

# TypeScript 类型工具 🔧

> `类型别名 type + 泛型 <T> => 工具类`

## 工具类

### 常见工具类

```ts
// keyof any => string | number | symbol
// 因为key只能为以上类型
type Record<K extends keyof any, T> = { [P in K]: T }

// 从T类型中排除U 返回 剩余的Key
type Exclude<T, U> = T extends U ? never : T

// 从T类型中 选取 K
type Pick<T, K extends keyof T> = { [P in K]: T[P] }

// 从T类型中 排除 K 字段
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>
```

## 操作符

### keyof

```ts
type Cat = {
  name: string
  age: number
}

// => 'name' | 'age' 联合类型
type Keys = keyof Cat
```

### typeof

```ts
const foo = {
  name: 'mmc',
  age: 17,
}
// => { name: string, age: number }
type Bar = typeof foo
```

### in 关键字

```ts
// 会遍历这个 keyof T返回的联合类型
type Readonly<T> = {
  readonly [P in keyof T]: T[P]
}

interface Foo {
  prop1: string
  prop2: number
  prop3: boolean
  prop4: () => void
}

type TestReadonly1 = Readonly<Foo>

// 等价于
interface TestReadonly2 {
  readonly prop1: string
  readonly prop2: number
  readonly prop3: boolean
  readonly prop4: () => void
}

// 用伪代码表示
const Foo = {}
for (const K of Object.keys(T)) {
  Foo[K] = readonly T[K]
}
```

### is 关键字

> is 关键字 + 预期类型

什么时候会用到 is

先看这个例子

```ts
function isString(value: unknown): boolean {
  return typeof value === 'string'
}

function foo(value: string | number) {
  if (isString(value)) {
    // 类型“string | number”上不存在属性“replace”。
    value.replace('mmc', 'huige666')
    // 因为 isString函数不在foo中，类型分析做不到跨函数上下信息收集
  }
  if (typeof value === 'number') {
    // ...
  }
}
```

为了解决这一类型控制流分析的能力不足, TypeScript 引入了 is 关键字来显式地提供类型信息

```ts
const isNumber = (value: unkown): value is number => {
  // 如果 return true 即为 预期类型
  return typeof value === 'number'
}
```

## 索引类型访问

```ts
interface StringMap {
  name: string
}
type String = StringMap['name'] // => string
```
